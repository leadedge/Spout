<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2) Porting.txt</title><link rel="stylesheet" type="text/css" href="../../styles/main.css" /><script type="text/javascript" src="../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.1 -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="Porting_from_2.006"></a><a name="Topic54"></a><div class="CTopic TSection LTextFile first">
 <div class="CTitle">Porting from 2.006</div>
 <div class="CBody"><p>Updating existing 2.006 projects</p></div>
</div>

<a name="New_files"></a><a name="Topic55"></a><div class="CTopic TGroup LTextFile">
 <div class="CTitle">New files</div>
 <div class="CBody"><p>Remove all 2.006 source files from your project and replace them :</p><pre>Spout.h<br />SpoutCommon.h<br />SpoutSDK.h<br />SpoutSDK.cpp<br />SpoutSender.h<br />SpoutSender.cpp<br />SpoutReceiver.h<br />SpoutReceiver.cpp<br />SpoutSharedMemory.h<br />SpoutSharedMemory.cpp<br />SpoutGL.h<br />SpoutGL.cpp<br />SpoutCopy.cpp<br />SpoutCopy.h<br />SpoutGLextensions.cpp<br />SpoutGLextensions.h<br />SpoutDirectX.h<br />SpoutDirectX.cpp<br />SpoutFrameCount.h<br />SpoutFrameCount.cpp<br />SpoutUtils.h<br />SpoutUtils.cpp</pre><p>If you have been using a dll, replace the header file(s) and linked library file, rebuild and use the new dll file.</p><p>As usual, the entire SDK can be included :</p><pre>#include <span class="SHString">&quot;Spout.h&quot;</span></pre><p>Or, to isolate sending and receiving functions for the programmer :</p><pre>#include <span class="SHString">&quot;SpoutSender.h&quot;</span><br />or<br />#include <span class="SHString">&quot;SpoutReceiver.h&quot;</span></pre></div>
</div>

<a name="Updating_projects"></a><a name="Topic56"></a><div class="CTopic TGroup LTextFile">
 <div class="CTitle">Updating projects</div>
 <div class="CBody"><p>The methods used in 2.006 still apply and existing code does not need to be changed. 2.007 includes methods for creating and using senders which are easier to use and simplify the code.</p></div>
</div>

<a name="Sender"></a><a name="Topic57"></a><div class="CTopic TGroup LTextFile">
 <div class="CTitle">Sender</div>
 <div class="CBody"><p>The&nbsp; “CreateSender” function can still be used as for 2.006, but is no longer necessary. Instead, simply specify a sender name.</p><pre><span class="SHKeyword">bool</span> SetSenderName(<span class="SHKeyword">const char</span> *sendername);</pre><p>If no name is specified, the application executable name will be used. Thereafter, all sending functions create and update a sender based on the size passed and the name that has been set.</p><pre><span class="SHKeyword">bool</span> SendTexture(GLuint TextureID, GLuint TextureTarget,<br />               <span class="SHKeyword">unsigned int</span> width, <span class="SHKeyword">unsigned int</span> height,<br />               <span class="SHKeyword">bool</span> bInvert = <span class="SHKeyword">true</span>, GLuint HostFBO = <span class="SHNumber">0</span>);</pre><p>SendTexture creates a shared texture for all receivers to access. The invert flag is optional and by default true. This flips the texture in the Y axis which is necessary because DirectX and OpenGL textures are opposite in Y. If it is set to false no flip occurs and the result may appear upside down.</p><p>The host fbo argument is optional, default 0. If an fbo is currently bound and it's ID passed, then that binding is restored within the SendTexture function.</p><pre><span class="SHKeyword">bool</span> SendImage(<span class="SHKeyword">const unsigned char</span>* pixels,<br />             <span class="SHKeyword">unsigned int</span> width, <span class="SHKeyword">unsigned int</span> height,<br />             GLenum glFormat = GL_RGBA,<br />             <span class="SHKeyword">bool</span> bInvert = <span class="SHKeyword">false</span>, GLuint HostFBO = <span class="SHNumber">0</span>);</pre><p>SendImage creates a shared texture using image pixels as the source instead of an OpenGL texture. The format of the image to be sent is RGBA by default but can be a different OpenGL format, for example GL_RGB or GL_BGRA_EXT. The invert flag is optional and false by default.</p><pre><span class="SHKeyword">bool</span> SendFbo(GLuint FboID,<br />             <span class="SHKeyword">unsigned int</span> width, <span class="SHKeyword">unsigned int</span> height,<br />          <span class="SHKeyword">bool</span> bInvert = <span class="SHKeyword">true</span>);</pre><p>&quot;SendFbo&quot; is a new function that uses a texture attached to the currently bound fbo. This is useful if the sending texture is larger than the size of the the sender, which can be the case if the application is using only a portion of the allocated texture space, such as for Freeframe plugins. This was previously achieved by rendering to the shared texture using the legacy OpenGL function &quot;DrawToSharedTexture&quot;.</p><p>At any time you can query the sender status, name, size, frame number and frame rate.</p><pre><span class="SHKeyword">bool</span> IsInitialized();<br /><span class="SHKeyword">const char</span> * GetName();<br /><span class="SHKeyword">unsigned int</span> GetWidth();<br /><span class="SHKeyword">unsigned int</span> GetHeight();<br /><span class="SHKeyword">double</span> GetFps();<br /><span class="SHKeyword">long</span> GetFrame();<br />HANDLE GetHandle();</pre></div>
</div>

<a name="Receiver"></a><a name="Topic81"></a><div class="CTopic TGroup LTextFile last">
 <div class="CTitle">Receiver</div>
 <div class="CBody"><p>“CreateReceiver” is no longer required because the functions connect to a sender and inform the application to update the receiving texture or buffer if it has changed dimensions.</p><p>1) Set receiver name</p><p>Although a create function is no longer necessary, you can still specify a sender name for the receiver to connect to. The application will not connect to any other unless the user selects one. If that sender closes, the application will wait for the nominated sender to open.</p><pre><span class="SHKeyword">void</span> SetReceiverName(<span class="SHKeyword">const char</span> * SenderName);</pre><p>2) Receive texture or pixel data</p><p>Note that “ReceiveTexture” and “ReceiveImage” have changed arguments.</p><pre>// Receive texture<br /><span class="SHKeyword">bool</span> ReceiveTexture();</pre><p>Once a sender has been detected, this function will receive shared textures from senders if the ID and Target are passed. The shared texture is internal to Spout and can be accessed using :</p><pre>BindSharedTexture();<br />UnBindSharedTexture();<br />GetSharedTextureID();</pre><pre>// Receive texture<br /><span class="SHKeyword">bool</span> ReceiveTexture(GLuint TextureID, GLuint TextureTarget,<br />               <span class="SHKeyword">bool</span> bInvert = <span class="SHKeyword">false</span>, GLuint HostFbo = <span class="SHNumber">0</span>);</pre><p>If the ID and Target are not passed, or the received shared texture can be used directly for graphics operations.</p><p>Any changes to sender size are managed within Spout, however if you are receiving to a local texture, the changed width or height are passed back and must be tested to adjust the receiving texture or for for maintaining window dimensions.</p><pre><span class="SHKeyword">bool</span> ReceiveImage(<span class="SHKeyword">unsigned char</span> * pixels, GLenum glFormat = GL_RGBA,<br />            <span class="SHKeyword">bool</span> bInvert = <span class="SHKeyword">false</span>, GLuint HostFBO = <span class="SHNumber">0</span>);</pre><p>Receives a sender shared texture into image pixels. The same sender size changes are passed back as for ReceiveTexture.</p><p>Formats supported are :</p><pre>GL_RGBA, GL_RGB, GL_BGRA_EXT, GL_BGR_EXT</pre><p>GL_BGRA_EXT, GL_BGR_EXT are dependent on those extensions being supported at runtime. If they are not the rgba and rgb equivalents are used. Note that images with padding on each line are not supported. Also the width should be a multiple of 4.</p><p>3) Query sender change</p><p>It is not necessary to keep local variables to monitor sender size changes. But the application must check for update at every cycle before receiving any data or receiving functions will fail.</p><pre><span class="SHKeyword">if</span>(receiver.IsUpdated()) {<br />    .. update the receiving texture or buffer<br />}</pre><p>4) Query sender connection</p><p>If the sender closes, the functions return false. But you can also test this at any time.</p><pre>If(receiver.IsConnected()) {<br />    .. perform processing as required<br />}</pre><p>5) Query frame status</p><p>The receiving texture or pixel buffer is only refreshed if the sender has produced a new frame. if there is any performance gain by processing the data only for new frames, This can be queried.</p><pre>receiver.ReceiveTexture( ... );<br /><span class="SHKeyword">if</span>(receiver.IsFrameNew()) {<br />    . . . perform processing<br />}<br />. . . render the received texture</pre><p>5) Query sender details</p><p>At any time you can retrieve the connected sender name, size, format, frame rate and number.</p><pre>// Sender name<br /><span class="SHKeyword">const char</span> * GetSenderName();<br />// Sender width<br /><span class="SHKeyword">unsigned int</span> GetSenderWidth();<br />// Sender height<br /><span class="SHKeyword">unsigned int</span> GetSenderHeight();<br />// Sender texture format<br />DWORD GetSenderFormat();<br />// Sender frame rate<br /><span class="SHKeyword">double</span> GetSenderFps();<br />// Sender frame number<br /><span class="SHKeyword">long</span> GetSenderFrame();</pre><p>6) Sender selection</p><pre><span class="SHKeyword">void</span> SelectSender();</pre><p>To improve legibility, this overload function replaces the 2.006 version “SelectSenderPanel”.</p></div>
</div>

</body></html>